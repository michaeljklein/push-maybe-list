-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/michaeljklein/push-maybe-list#readme</a>
@package push-maybe-list
@version 0.1.0.0

module Lib

-- | The "natural" partition of a list of <a>Maybe</a>'s: we group
--   <a>Nothing</a>'s and <a>Just</a>'s and the outermost <a>Maybe</a>
--   marks which is contained.
partMaybes :: [Maybe a] -> [Maybe [Maybe a]]

-- | Convert the "natural" partition into a partition that we can more
--   easily push through the innermost <a>Maybe</a>: replace
--   <a>Nothing</a>'s with an empty lists and drop <a>Just</a>'s.
unMaybeParts :: [Maybe [Maybe a]] -> [[Maybe a]]

-- | <pre>
--   <a>unMaybeParts</a> . <a>partMaybes</a>
--   </pre>
partMaybe :: [Maybe a] -> [[Maybe a]]

-- | Reassociate the list and <a>Maybe</a>
dartMaybe :: [[Maybe a]] -> [Maybe [a]]

-- | <pre>
--   <a>dartMaybe</a> . <a>partMaybe</a>
--   </pre>
pushMaybe :: [Maybe a] -> [Maybe [a]]

-- | Convert from pushed preserving <a>Nothing</a>'s
fromPushed :: [Maybe [a]] -> [Maybe a]

-- | Replace runs of multiple <a>Nothing</a>'s with single <a>Nothing</a>'s
simplifyNothings :: [Maybe a] -> [Maybe a]

-- | <pre>
--   <a>fromPushed</a> . <a>pushMaybe</a> == <a>simplifyNothings</a>
--   </pre>
fromPushedIsSimplified :: Eq a => [Maybe a] -> Bool

-- | Drop the <a>Nothing</a>'s and flatten the resulting list
flattenPushed :: [Maybe [a]] -> [a]

-- | <pre>
--   <a>flattenPushed</a> . <a>pushMaybe</a> == <a>catMaybes</a>
--   </pre>
flattenPushedIsCatMaybes :: Eq a => [Maybe a] -> Bool

-- | To a reversed list of he binary digits of the input
toBin :: (Bits a, Eq a, Enum a) => a -> [a]

-- | If <a>False</a> then <a>Nothing</a> else <a>Just</a>, zipped
toMaybes :: [Bool] -> [a] -> [Maybe a]

-- | Use <a>toBin</a> to get the list of <a>Bool</a>'s and use
--   <tt>[1..]</tt> as the list of values. The first argument is the length
--   and the second is the index.
enumMaybes :: (Bits a, Eq a, Enum a) => Int -> a -> [Maybe a]

-- | Apply a test to <a>enumMaybes</a> up to the given maximums. Return any
--   counterexamples.
testEnumMaybes :: ([Maybe Int] -> Bool) -> Int -> Int -> [[Maybe Int]]

-- | Throw an error if the test fails on any input <a>enumMaybes</a>
assertEnumMaybes :: String -> ([Maybe Int] -> Bool) -> Int -> Int -> IO ()
runTests :: IO ()

-- | Notes on digraphs:
--   
--   <pre>
--   newtype Digraph = Digraph { digraphMatrix :: Matrix Bool }
--   
--   data DigraphGen = DigraphGen
--     { currentDigraph :: Digraph
--     , currentArc :: Arc
--     , newDigraph :: Bool
--     }
--   
--   We can enumerate the non (i, i) arcs in (join liftM2 (,) [1..n])
--   
--   this gives us an Enum instance for (ArcN (n :: Nat))
--   
--   newtype ArcN (n :: Nat) = ArcN { toArc :: Arc }
--   </pre>
digraphNotes :: ()
